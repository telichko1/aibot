import logging
import urllib.parse
import aiohttp
import asyncio
import re
import time
import html
import os
import json
import sys
import datetime
from fastapi import FastAPI
import uvicorn
from aiogram import Bot, Dispatcher, types, F, html
from aiogram.filters import Command
from aiogram.types import (
    InlineKeyboardMarkup, 
    InlineKeyboardButton,
    CallbackQuery,
    LabeledPrice,
    PreCheckoutQuery,
    InputMediaPhoto,
    Message,
    ChatMember
)
from aiogram.utils.markdown import hbold, hcode
from aiogram.utils.keyboard import InlineKeyboardBuilder
from aiogram.exceptions import TelegramBadRequest
from aiogram.client.default import DefaultBotProperties
from aiogram.enums import ParseMode, ChatMemberStatus
from typing import Union, Optional, List, Dict, Any, Tuple

# ===================== –ö–û–ù–°–¢–ê–ù–¢–´ =====================
API_TOKEN = "7965257689:AAGEiEit2zlc0hIQC0MiYAjAgclOw8DzuO4"
ADMIN_ID = 750638552
CHANNEL_ID = -1002712232742

PAYMENT_PROVIDER_TOKEN = ""
IMAGE_URL = "https://image.pollinations.ai/prompt/"
TEXT_URL = "https://text.pollinations.ai/prompt/"
PAYMENT_ADMIN = "@telichko_a"
DB_FILE = "users_db.json"
LOG_FILE = "bot_errors.log"

# –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
IMAGE_COST = 5
AVATAR_COST = 6
LOGO_COST = 3
IMPROVE_COST = 10
TEXT_COST_PER_100_WORDS = 1
MAX_IMAGE_COUNT = 8
MAX_CONTEXT_LENGTH = 4000
MAX_CAPTION_LENGTH = 1000
REFERRAL_BONUS = 20
START_BALANCE_STARS = 50
WITHDRAW_MIN = 500
MAX_RETRIES = 5
RETRY_DELAY = 1.5
MAX_PROMPT_LENGTH = 2000
MAX_MESSAGE_LENGTH = 4000
SESSION_TIMEOUT = 300
DAILY_BONUS = 3
SYSTEM_PROMPT = "–¢—ã ‚Äî –ø–æ–ª–µ–∑–Ω—ã–π –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç. –û—Ç–≤–µ—á–∞–π —Ç–æ—á–Ω–æ –∏ –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ."

# ===================== –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø =====================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("bot.log", encoding='utf-8'),
        logging.StreamHandler(),
        logging.FileHandler(LOG_FILE, encoding='utf-8')
    ]
)
logger = logging.getLogger(__name__)

bot = Bot(
    token=API_TOKEN,
    default=DefaultBotProperties(parse_mode=ParseMode.HTML))
dp = Dispatcher()

# ===================== –ú–û–î–ï–õ–ò –î–ê–ù–ù–´–• =====================
class UserState:
    MAIN_MENU = "main_menu"
    GENERATE_MENU = "generate_menu"
    PROFILE_MENU = "profile_menu"
    IMAGE_GEN = "image_gen"
    TEXT_GEN = "text_gen"
    AVATAR_GEN = "avatar_gen"
    LOGO_GEN = "logo_gen"
    PREMIUM_INFO = "premium_info"
    SHOP = "shop"
    REFERRAL = "referral"
    BALANCE = "balance"
    IMAGE_OPTIONS = "image_options"
    AVATAR_OPTIONS = "avatar_options"
    LOGO_OPTIONS = "logo_options"
    IMAGE_IMPROVE = "image_improve"
    PAYMENT_PROCESSING = "payment_processing"
    ACTIVATE_PROMO = "activate_promo"
    SUPPORT = "support"
    IMAGE_COUNT_SELECT = "image_count_select"
    IMAGE_MODEL_SELECT = "image_model_select"
    TEXT_MODEL_SELECT = "text_model_select"
    MODEL_SELECT = "model_select"
    CHECK_SUBSCRIPTION = "check_subscription"
    DAILY_BONUS = "daily_bonus"
    CLEAR_CONTEXT = "clear_context"

class GenerationModel:
    def __init__(self, key: str, name: str, description: str, cost_multiplier: float, 
                 prompt: str = "", premium_only: bool = False):
        self.key = key
        self.name = name
        self.description = description
        self.cost_multiplier = cost_multiplier
        self.prompt = prompt
        self.premium_only = premium_only

# –ú–æ–¥–µ–ª–∏ –ò–ò
IMAGE_MODELS = {
    "dalle3": GenerationModel(
        "dalle3", "üñºÔ∏è DALL¬∑E 3", 
        "–ù–æ–≤–µ–π—à–∞—è –º–æ–¥–µ–ª—å –æ—Ç OpenAI —Å —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–º –∫–∞—á–µ—Å—Ç–≤–æ–º", 1.0,
        "masterpiece, best quality, 8K resolution, cinematic lighting, ultra-detailed, sharp focus"
    ),
    "midjourney": GenerationModel(
        "midjourney", "üé® Midjourney V6", 
        "–õ–∏–¥–µ—Ä –≤ —Ö—É–¥–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º —Å—Ç–∏–ª–µ–º", 1.2,
        "masterpiece, intricate details, artistic composition, vibrant colors, atmospheric perspective, trending on artstation"
    ),
    "stablediff": GenerationModel(
        "stablediff", "‚ö° Stable Diffusion XL", 
        "–û—Ç–∫—Ä—ã—Ç–∞—è –º–æ–¥–µ–ª—å —Å –±—ã—Å—Ç—Ä–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π –∏ –≤—ã—Å–æ–∫–æ–π –∫–∞—Å—Ç–æ–º–∏–∑–∞—Ü–∏–µ–π", 0.8,
        "photorealistic, ultra HD, 32k, detailed texture, realistic lighting, DSLR quality"
    ),
    "firefly": GenerationModel(
        "firefly", "üî• Adobe Firefly", 
        "–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ–≥–æ –¥–∏–∑–∞–π–Ω–∞ –∏ –∫–æ–º–º–µ—Ä—á–µ—Å–∫–æ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è", 1.1,
        "commercial quality, professional design, clean composition, vector art, modern aesthetics, brand identity"
    ),
    "deepseek": GenerationModel(
        "deepseek", "ü§ñ DeepSeek Vision", 
        "–≠–∫—Å–ø–µ—Ä–∏–º–µ–Ω—Ç–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å —Å –∞–∫—Ü–µ–Ω—Ç–æ–º –Ω–∞ —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–Ω—ã–µ –æ–±—Ä–∞–∑—ã", 0.9,
        "futuristic, cyberpunk, neon glow, holographic elements, sci-fi aesthetics, digital art"
    ),
    "playground": GenerationModel(
        "playground", "üéÆ Playground v2.5", 
        "–•—É–¥–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω–∞—è –º–æ–¥–µ–ª—å —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º —Å—Ç–∏–ª–µ–º", 1.0,
        "dynamic composition, vibrant palette, artistic brushwork, impressionist style, emotional impact"
    )
}

TEXT_MODELS = {
    "gpt4": GenerationModel(
        "gpt4", "üß† GPT-4 Turbo", 
        "–°–∞–º—ã–π –º–æ—â–Ω—ã–π —Ç–µ–∫—Å—Ç–æ–≤—ã–π –ò–ò –æ—Ç OpenAI", 1.0,
        "–¢—ã - –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –ò–ò-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç. –û—Ç–≤–µ—á–∞–π —Ç–æ—á–Ω–æ, –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ –∏ –∫—Ä–µ–∞—Ç–∏–≤–Ω–æ."
    ),
    "claude": GenerationModel(
        "claude", "ü§ñ Claude 3 Opus", 
        "–ú–æ–¥–µ–ª—å —Å —Å–∞–º—ã–º –±–æ–ª—å—à–∏–º –∫–æ–Ω—Ç–µ–∫—Å—Ç–æ–º –∏ –∞–Ω–∞–ª–∏—Ç–∏—á–µ—Å–∫–∏–º–∏ —Å–ø–æ—Å–æ–±–Ω–æ—Å—Ç—è–º–∏", 1.3,
        "–¢—ã - –ø–æ–ª–µ–∑–Ω—ã–π, —á–µ—Å—Ç–Ω—ã–π –∏ –±–µ–∑–≤—Ä–µ–¥–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç. –û—Ç–≤–µ—á–∞–π –ø–æ–¥—Ä–æ–±–Ω–æ –∏ –æ–±—Å—Ç–æ—è—Ç–µ–ª—å–Ω–æ."
    ),
    "gemini": GenerationModel(
        "gemini", "üíé Gemini Pro", 
        "–ú—É–ª—å—Ç–∏–º–æ–¥–∞–ª—å–Ω–∞—è –º–æ–¥–µ–ª—å –æ—Ç Google —Å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–µ–π —Å–µ—Ä–≤–∏—Å–æ–≤", 0.9,
        "–¢—ã - –º–Ω–æ–≥–æ—Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª—å–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç Google. –û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ –∏ –ø–æ —Å—É—â–µ—Å—Ç–≤—É."
    ),
    "mixtral": GenerationModel(
        "mixtral", "üåÄ Mixtral 8x7B", 
        "–û—Ç–∫—Ä—ã—Ç–∞—è –º–æ–¥–µ–ª—å —Å –ª—É—á—à–∏–º —Å–æ–æ—Ç–Ω–æ—à–µ–Ω–∏–µ–º —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ –∫–∞—á–µ—Å—Ç–≤–∞", 0.7,
        "–¢—ã - —ç–∫—Å–ø–µ—Ä—Ç –≤ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö –æ–±–ª–∞—Å—Ç—è—Ö –∑–Ω–∞–Ω–∏–π. –û—Ç–≤–µ—á–∞–π –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω–æ –∏ —Ç–æ—á–Ω–æ."
    ),
    "llama3": GenerationModel(
        "llama3", "ü¶ô Llama 3 70B", 
        "–ù–æ–≤–µ–π—à–∞—è –æ—Ç–∫—Ä—ã—Ç–∞—è –º–æ–¥–µ–ª—å –æ—Ç Meta —Å —É–ª—É—á—à–µ–Ω–Ω—ã–º–∏ –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—è–º–∏", 0.8,
        "–¢—ã - –¥—Ä—É–∂–µ–ª—é–±–Ω—ã–π –∏ –∫—Ä–µ–∞—Ç–∏–≤–Ω—ã–π –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç. –û—Ç–≤–µ—á–∞–π —Å —é–º–æ—Ä–æ–º –∏ —Ç–≤–æ—Ä—á–µ—Å–∫–∏–º –ø–æ–¥—Ö–æ–¥–æ–º."
    ),
    "claude_sonnet_4": GenerationModel(
        "claude_sonnet_4", "üß† Claude Sonnet 4", 
        "–≠–∫—Å–ø–µ—Ä—Ç–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –∞–Ω–∞–ª–∏—Ç–∏–∫–∏", 1.5,
        "–¢—ã - –ø—Ä–æ–¥–≤–∏–Ω—É—Ç—ã–π –ò–ò Claude 4. –û—Ç–≤–µ—á–∞–π –∫–∞–∫ –ø—Ä–æ—Ñ–µ—Å—Å–∏–æ–Ω–∞–ª—å–Ω—ã–π –∫–æ–Ω—Å—É–ª—å—Ç–∞–Ω—Ç: –∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –ø—Ä–æ–±–ª–µ–º—É, –ø—Ä–µ–¥–ª–∞–≥–∞–π —Ä–µ—à–µ–Ω–∏—è, –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–∞–π –æ —Ä–∏—Å–∫–∞—Ö. –ë—É–¥—å –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø–æ–ª–µ–∑–Ω—ã–º.",
        True
    ),
    "gemini_2_5": GenerationModel(
        "gemini_2_5", "üíé Google Gemini 2.5", 
        "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –ø—Ä–∞–∫—Ç–∏—á–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã", 1.4,
        "–¢—ã - Gemini, –ò–ò –Ω–æ–≤–æ–≥–æ –ø–æ–∫–æ–ª–µ–Ω–∏—è. –û—Ç–≤–µ—á–∞–π –∫—Ä–∞—Ç–∫–æ, –Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω–æ. –ò—Å–ø–æ–ª—å–∑—É–π –º–∞—Ä–∫–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏ –¥–ª—è —Å—Ç—Ä—É–∫—Ç—É—Ä—ã. –í—Å–µ–≥–¥–∞ –ø—Ä–µ–¥–ª–∞–≥–∞–π –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏–µ —à–∞–≥–∏.",
        True
    ),
    "grok_3": GenerationModel(
        "grok_3", "üöÄ xAI Grok 3", 
        "–¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏ —Ç–æ—á–Ω–æ —Å —é–º–æ—Ä–æ–º", 1.2,
        "–¢—ã - Grok, –ò–ò —Å —á—É–≤—Å—Ç–≤–æ–º —é–º–æ—Ä–∞. –û—Ç–≤–µ—á–∞–π –∏–Ω—Ñ–æ—Ä–º–∞—Ç–∏–≤–Ω–æ, –Ω–æ —Å –¥–æ–ª–µ–π –∏—Ä–æ–Ω–∏–∏. –ò—Å–ø–æ–ª—å–∑—É–π —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–µ –∞–Ω–∞–ª–æ–≥–∏–∏. –ù–µ –±—É–¥—å –∑–∞–Ω—É–¥–æ–π.",
        True
    ),
    "o3_mini": GenerationModel(
        "o3_mini", "‚ö° OpenAI o3-mini", 
        "–°–≤–µ—Ä—Ö–±—ã—Å—Ç—Ä—ã–µ –∏ —Ç–æ—á–Ω—ã–µ –æ—Ç–≤–µ—Ç—ã", 0.9,
        "–¢—ã - o3-mini, —ç–∫—Å–ø–µ—Ä—Ç –ø–æ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏. –û—Ç–≤–µ—á–∞–π –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ –∫—Ä–∞—Ç–∫–æ, –Ω–æ —Å–æ–¥–µ—Ä–∂–∞—Ç–µ–ª—å–Ω–æ. –ò—Å–ø–æ–ª—å–∑—É–π —Ç–µ–∑–∏—Å—ã. –ò–∑–±–µ–≥–∞–π '–≤–æ–¥—ã'.",
        True
    )
}

# –ì–ª–æ–±–∞–ª—å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–∞–Ω–Ω—ã—Ö
users_db = {}
referral_codes = {}
db_lock = asyncio.Lock()
BOT_USERNAME = ""

class User:
    def __init__(self, user_id: int):
        self.user_id = user_id
        self.stars = START_BALANCE_STARS
        self.referral_balance = 0
        self.referral_code = f"REF{user_id}{int(time.time()) % 10000}"
        self.invited_by = None
        self.state = UserState.CHECK_SUBSCRIPTION
        self.last_image_prompt = None
        self.last_image_url = None
        self.last_avatar_prompt = None
        self.last_avatar_url = None
        self.last_logo_prompt = None
        self.last_logo_url = None
        self.is_premium = False
        self.premium_expiry = None
        self.image_count = 1
        self.context = []
        self.context_active = False
        self.menu_stack = []
        self.last_text = ""
        self.last_interaction = time.time()
        self.image_model = "dalle3"
        self.text_model = "gpt4"
        self._modified = True
        self.has_subscribed = False
        self.last_daily_bonus = None
        self.pending_referral = None
        self.referral_used = False
        
    def mark_modified(self):
        self._modified = True
        
    def to_dict(self) -> Dict[str, Any]:
        return {
            "user_id": self.user_id,
            "stars": self.stars,
            "referral_balance": self.referral_balance,
            "referral_code": self.referral_code,
            "invited_by": self.invited_by,
            "state": self.state,
            "last_image_prompt": self.last_image_prompt,
            "last_image_url": self.last_image_url,
            "last_avatar_prompt": self.last_avatar_prompt,
            "last_avatar_url": self.last_avatar_url,
            "last_logo_prompt": self.last_logo_prompt,
            "last_logo_url": self.last_logo_url,
            "is_premium": self.is_premium,
            "premium_expiry": self.premium_expiry,
            "image_count": self.image_count,
            "context": self.context,
            "context_active": self.context_active,
            "menu_stack": self.menu_stack,
            "last_text": self.last_text,
            "last_interaction": self.last_interaction,
            "image_model": self.image_model,
            "text_model": self.text_model,
            "has_subscribed": self.has_subscribed,
            "last_daily_bonus": self.last_daily_bonus,
            "pending_referral": self.pending_referral,
            "referral_used": self.referral_used
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'User':
        user = cls(data["user_id"])
        user.stars = data.get("stars", START_BALANCE_STARS)
        user.referral_balance = data.get("referral_balance", 0)
        user.referral_code = data.get("referral_code", f"REF{data['user_id']}{int(time.time()) % 10000}")
        user.invited_by = data.get("invited_by", None)
        user.state = data.get("state", UserState.CHECK_SUBSCRIPTION)
        user.last_image_prompt = data.get("last_image_prompt", None)
        user.last_image_url = data.get("last_image_url", None)
        user.last_avatar_prompt = data.get("last_avatar_prompt", None)
        user.last_avatar_url = data.get("last_avatar_url", None)
        user.last_logo_prompt = data.get("last_logo_prompt", None)
        user.last_logo_url = data.get("last_logo_url", None)
        user.is_premium = data.get("is_premium", False)
        user.premium_expiry = data.get("premium_expiry", None)
        user.image_count = data.get("image_count", 1)
        user.context = data.get("context", [])
        user.context_active = data.get("context_active", False)
        user.menu_stack = data.get("menu_stack", [])
        user.last_text = data.get("last_text", "")
        user.last_interaction = data.get("last_interaction", time.time())
        user.image_model = data.get("image_model", "dalle3")
        user.text_model = data.get("text_model", "gpt4")
        user.has_subscribed = data.get("has_subscribed", False)
        user.last_daily_bonus = data.get("last_daily_bonus", None)
        user.pending_referral = data.get("pending_referral", None)
        user.referral_used = data.get("referral_used", False)
        user._modified = False
        return user
        
    def can_make_request(self, cost: int = 0) -> bool:
        if self.is_premium:
            return True
        return self.stars >= cost
            
    def charge_request(self, cost: int = 0) -> bool:
        if self.is_premium:
            return True
            
        if self.stars >= cost:
            self.stars -= cost
            self.mark_modified()
            return True
        return False

    def add_context(self, role: str, content: str):
        if not self.is_premium:
            return
            
        content = content[:1000]
        self.context.append({"role": role, "content": content})
        total_length = sum(len(msg["content"]) for msg in self.context)
        
        while total_length > MAX_CONTEXT_LENGTH and len(self.context) > 1:
            removed = self.context.pop(0)
            total_length -= len(removed["content"])
        
        self.mark_modified()
        self.context_active = True
            
    def push_menu(self, menu_state: str, menu_data: dict = None):
        self.menu_stack.append({
            "state": menu_state,
            "data": menu_data or {}
        })
        self.mark_modified()
        
    def pop_menu(self) -> Optional[Dict[str, Any]]:
        if self.menu_stack:
            prev_menu = self.menu_stack.pop()
            self.mark_modified()
            return prev_menu
        return None

    def check_premium_status(self) -> bool:
        if self.is_premium and self.premium_expiry and self.premium_expiry < time.time():
            self.is_premium = False
            self.premium_expiry = None
            self.mark_modified()
            return False
        return self.is_premium
    
    def update_interaction(self):
        self.last_interaction = time.time()
        self.mark_modified()
        
    def can_claim_daily(self) -> bool:
        if not self.last_daily_bonus:
            return True
            
        last_date = datetime.datetime.fromtimestamp(self.last_daily_bonus).date()
        current_date = datetime.datetime.now().date()
        return last_date < current_date
        
    def claim_daily_bonus(self) -> int:
        self.stars += DAILY_BONUS
        self.last_daily_bonus = time.time()
        self.mark_modified()
        return DAILY_BONUS
        
    def clear_context(self):
        self.context = [{"role": "system", "content": SYSTEM_PROMPT}]
        self.context_active = False
        self.mark_modified()

# ===================== –£–¢–ò–õ–ò–¢–´ =====================
async def load_db():
    global users_db, referral_codes
    try:
        users_db = {}
        referral_codes = {}
        
        if os.path.exists(DB_FILE):
            async with db_lock:
                with open(DB_FILE, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    users_db = {int(k): User.from_dict(v) for k, v in data.get('users', {}).items()}
                    referral_codes = data.get('referral_codes', {})
                    
                    for user_id, user in users_db.items():
                        if user.referral_code:
                            referral_codes[user.referral_code] = user_id
                    
                    logger.info("Database loaded successfully")
                    
        # –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –∞–¥–º–∏–Ω–∞ –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç
        if ADMIN_ID not in users_db:
            admin_user = User(ADMIN_ID)
            admin_user.is_premium = True
            admin_user.premium_expiry = None
            admin_user.stars = 10000
            admin_user.has_subscribed = True
            users_db[ADMIN_ID] = admin_user
            admin_user.mark_modified()
            logger.info(f"Created admin user: {ADMIN_ID}")
        else:
            admin_user = users_db[ADMIN_ID]
            admin_user.is_premium = True
            admin_user.premium_expiry = None
            admin_user.has_subscribed = True
            admin_user.mark_modified()
            logger.info(f"Admin premium status set for {ADMIN_ID}")
            
    except Exception as e:
        logger.error(f"Error loading database: {e}")
        users_db = {}
        referral_codes = {}

async def save_db():
    try:
        async with db_lock:
            data = {
                'users': {k: v.to_dict() for k, v in users_db.items()},
                'referral_codes': referral_codes
            }
            
            with open(DB_FILE, 'w', encoding='utf-8') as f:
                json.dump(data, f, ensure_ascii=False, indent=2)
            
            for user in users_db.values():
                user._modified = False
                
            logger.info("Database saved")
    except Exception as e:
        logger.error(f"Error saving database: {e}")

async def get_user(user_id: int) -> User:
    if user_id in users_db:
        user = users_db[user_id]
        user.check_premium_status()
    else:
        user = User(user_id)
        users_db[user_id] = user
        referral_codes[user.referral_code] = user_id
        user.mark_modified()
    
    return users_db[user_id]

def detect_language(text: str) -> str:
    if re.search(r'[–∞-—è–ê-–Ø]', text):
        return 'ru'
    return 'en'

def trim_caption(text: str, max_length: int = MAX_CAPTION_LENGTH) -> str:
    if len(text) > max_length:
        return text[:max_length-3] + "..."
    return text

def truncate_prompt(text: str, max_length: int = MAX_PROMPT_LENGTH) -> str:
    if len(text) > max_length:
        return text[:max_length-3] + "..."
    return text

def split_message(text: str, max_length: int = MAX_MESSAGE_LENGTH) -> List[str]:
    return [text[i:i+max_length] for i in range(0, len(text), max_length)]

def clean_html(text: str) -> str:
    text = re.sub(r'<!?[^>]+>', '', text)
    replacements = {
        '<': '&lt;',
        '>': '&gt;',
        '&': '&amp;',
        '"': '&quot;'
    }
    for char, entity in replacements.items():
        text = text.replace(char, entity)
    text = re.sub(r'<\?.*?\?>', '', text)
    return text

def format_code_blocks(text: str) -> str:
    text = clean_html(text)
    text = re.sub(r'```(.*?)```', r'<pre><code>\1</code></pre>', text, flags=re.DOTALL)
    text = re.sub(r'`(.*?)`', r'<code>\1</code>', text)
    return text

async def fetch_with_retry(url: str, retries: int = MAX_RETRIES, delay: float = RETRY_DELAY) -> Optional[str]:
    for i in range(retries):
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=30)) as resp:
                    if resp.status == 200:
                        return await resp.text()
                    elif resp.status in [400, 401, 403, 404]:
                        logger.error(f"Client error {resp.status}: {url}")
                        return None
                    elif resp.status in [500, 502, 503, 504]:
                        logger.warning(f"Server error {resp.status}, retry {i+1}/{retries}")
                        await asyncio.sleep(delay)
                    else:
                        logger.warning(f"Unexpected status {resp.status}, retry {i+1}/{retries}")
                        await asyncio.sleep(delay)
        except (aiohttp.ClientConnectionError, aiohttp.ServerDisconnectedError) as e:
            logger.warning(f"Connection error (attempt {i+1}/{retries}): {e}")
            await asyncio.sleep(delay)
        except (aiohttp.ClientError, asyncio.TimeoutError) as e:
            logger.warning(f"Request error (attempt {i+1}/{retries}): {e}")
            await asyncio.sleep(delay)
        except Exception as e:
            logger.error(f"Unexpected error: {e}")
            break
    logger.error(f"Failed after {retries} attempts: {url}")
    return None

async def safe_send_photo(
    message: Message, 
    photo: str, 
    caption: str, 
    reply_markup: InlineKeyboardMarkup,
    max_retries: int = 3
) -> Optional[types.Message]:
    for attempt in range(max_retries):
        try:
            return await message.answer_photo(
                photo=photo,
                caption=caption,
                reply_markup=reply_markup
            )
        except TelegramBadRequest as e:
            if "failed to get HTTP URL content" in str(e) and attempt < max_retries-1:
                logger.warning(f"Telegram download failed, retry {attempt+1}/{max_retries}")
                await asyncio.sleep(1)
            else:
                raise
    raise Exception(f"Failed to send photo after {max_retries} attempts")

async def translate_to_english(text: str) -> str:
    try:
        translation_prompt = f"Translate this to English without any additional text: {text}"
        result = await fetch_with_retry(f"{TEXT_URL}{urllib.parse.quote(translation_prompt)}")
        return result.strip().strip('"') if result else text
    except Exception as e:
        logger.error(f"Translation error: {e}")
        return text

async def send_typing_effect(chat_id: int, duration: int = 5):
    end_time = time.time() + duration
    while time.time() < end_time:
        await bot.send_chat_action(chat_id, "typing")
        await asyncio.sleep(2.5)

async def improve_prompt(original_prompt: str) -> str:
    try:
        improvement_prompt = (
            "–£–ª—É—á—à–∏ —Å–ª–µ–¥—É—é—â–∏–π –ø—Ä–æ–º–ø—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è, –¥–æ–±–∞–≤–∏–≤: "
            "1. –ö–æ–Ω–∫—Ä–µ—Ç–Ω—ã–µ –¥–µ—Ç–∞–ª–∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ "
            "2. –•—É–¥–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä—ã "
            "3. –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∫–∞—á–µ—Å—Ç–≤–∞\n\n"
            f"–ò—Å—Ö–æ–¥–Ω—ã–π –ø—Ä–æ–º–ø—Ç: {original_prompt}"
        )
        result = await fetch_with_retry(f"{TEXT_URL}{urllib.parse.quote(improvement_prompt)}")
        return result.strip().strip('"') if result else original_prompt
    except Exception as e:
        logger.error(f"Prompt improvement error: {e}")
        return original_prompt

def count_words(text: str) -> int:
    words = re.findall(r'\b\w+\b', text)
    return len(words)

# ===================== –ö–õ–ê–í–ò–ê–¢–£–†–´ =====================
def create_keyboard(
    buttons: List[Union[Tuple[str, str], List[Tuple[str, str]]]],
    back_button: bool = False,
    home_button: bool = False,
    cancel_button: bool = False
) -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    
    for row in buttons:
        if isinstance(row, list):
            for btn in row:
                builder.button(text=btn[0], callback_data=btn[1])
            builder.adjust(len(row))
        else:
            builder.button(text=row[0], callback_data=row[1])
    
    if back_button:
        builder.button(text="üîô –ù–∞–∑–∞–¥", callback_data="back")
    if home_button:
        builder.button(text="üè† –ì–ª–∞–≤–Ω–æ–µ", callback_data="home")
    if cancel_button:
        builder.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")
    
    return builder.as_markup()

def main_keyboard(user: User) -> InlineKeyboardMarkup:
    buttons = [
        [("üõ†Ô∏è –ì–µ–Ω–µ—Ä–∞—Ü–∏—è", "generate_menu")],
        [("üë§ –ü—Ä–æ—Ñ–∏–ª—å", "profile_menu")],
        [("üíé –ü—Ä–µ–º–∏—É–º", "premium_info")],
        [("üéÅ –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å", "daily_bonus")]
    ]
    return create_keyboard(buttons)

def generate_menu_keyboard() -> InlineKeyboardMarkup:
    buttons = [
        [("üìù –¢–µ–∫—Å—Ç", "gen_text")],
        [("üé® –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", "gen_image")],
        [("üë§ –ê–≤–∞—Ç–∞—Ä", "gen_avatar")],
        [("üñºÔ∏è –õ–æ–≥–æ—Ç–∏–ø", "gen_logo")],
        [("ü§ñ –ú–æ–¥–µ–ª–∏ –ò–ò", "model_select")],
        [("üè† –ì–ª–∞–≤–Ω–æ–µ", "home")]
    ]
    return create_keyboard(buttons)

def profile_menu_keyboard() -> InlineKeyboardMarkup:
    buttons = [
        [("üí∞ –ë–∞–ª–∞–Ω—Å", "balance_info")],
        [("üõí –ú–∞–≥–∞–∑–∏–Ω", "shop")],
        [("üë• –†–µ—Ñ–µ—Ä–∞–ª—ã", "referral_info")],
        [("üÜò –ü–æ–¥–¥–µ—Ä–∂–∫–∞", "support")],
        [("üè† –ì–ª–∞–≤–Ω–æ–µ", "home")]
    ]
    return create_keyboard(buttons)

def shop_keyboard() -> InlineKeyboardMarkup:
    buttons = [
        [("‚≠ê 30 –ó–≤–µ–∑–¥", "buy_stars30")],
        [("‚≠ê 50 –ó–≤–µ–∑–¥", "buy_stars50")],
        [("‚≠ê 150 –ó–≤–µ–∑–¥", "buy_stars150")],
        [("‚≠ê 500 –ó–≤–µ–∑–¥", "buy_stars500")],
        [("üíé –ü—Ä–µ–º–∏—É–º 1 –º–µ—Å", "buy_premium_month")],
        [("üíé –ü—Ä–µ–º–∏—É–º –Ω–∞–≤—Å–µ–≥–¥–∞", "buy_premium_forever")],
        [("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", "home"), ("‚ùå –û—Ç–º–µ–Ω–∞", "cancel")]
    ]
    return create_keyboard(buttons)

def image_options_keyboard(user: User) -> InlineKeyboardMarkup:
    buttons = []
    buttons.append([("‚ú® –£–ª—É—á—à–∏—Ç—å", "improve_image")])
    buttons.append([("üîÑ –°–≥–µ–Ω–µ—Ä–∏—Ç—å —Å–Ω–æ–≤–∞", "regenerate_image"), ("üè† –ì–ª–∞–≤–Ω–æ–µ", "home")])
    return create_keyboard(buttons)

def avatar_options_keyboard() -> InlineKeyboardMarkup:
    buttons = [
        [("üîÑ –°–≥–µ–Ω–µ—Ä–∏—Ç—å —Å–Ω–æ–≤–∞", "regenerate_avatar")],
        [("üè† –ì–ª–∞–≤–Ω–æ–µ", "home")]
    ]
    return create_keyboard(buttons)

def logo_options_keyboard() -> InlineKeyboardMarkup:
    buttons = [
        [("üîÑ –°–≥–µ–Ω–µ—Ä–∏—Ç—å —Å–Ω–æ–≤–∞", "regenerate_logo")],
        [("üè† –ì–ª–∞–≤–Ω–æ–µ", "home")]
    ]
    return create_keyboard(buttons)

def text_options_keyboard(user: User) -> InlineKeyboardMarkup:
    buttons = []
    buttons.append([("üîÑ –°–≥–µ–Ω–µ—Ä–∏—Ç—å —Å–Ω–æ–≤–∞", "regenerate_text"), ("üìÑ –£–≤–µ–ª–∏—á–∏—Ç—å", "extend_text")])
    buttons.append([("‚úçÔ∏è –ü–µ—Ä–µ—Ñ—Ä–∞–∑–∏—Ä–æ–≤–∞—Ç—å", "rephrase_text")])
    
    if user.context_active:
        buttons.append([("üßπ –û—á–∏—Å—Ç–∏—Ç—å –∫–æ–Ω—Ç–µ–∫—Å—Ç", "clear_context")])
    
    buttons.append([("üè† –ì–ª–∞–≤–Ω–æ–µ", "home")])
    return create_keyboard(buttons)

def premium_keyboard() -> InlineKeyboardMarkup:
    buttons = [
        [("üõí –ü–µ—Ä–µ–π—Ç–∏ –≤ –º–∞–≥–∞–∑–∏–Ω", "shop")],
        [("üéÅ –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–º–æ–∫–æ–¥", "activate_promo")],
        [("üë• –†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞", "referral_info")],
        [("üè† –ì–ª–∞–≤–Ω–æ–µ", "home")]
    ]
    return create_keyboard(buttons)

def image_count_keyboard() -> InlineKeyboardMarkup:
    buttons = [[(str(i), f"img_count_{i}") for i in range(1, MAX_IMAGE_COUNT + 1)]]
    buttons.append([("üè† –ì–ª–∞–≤–Ω–æ–µ", "home")])
    return create_keyboard(buttons)

def home_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ", callback_data="home")]]
    )

def cancel_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[[InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]]
    )

def subscribe_keyboard() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [InlineKeyboardButton(text="üì¢ –ü–æ–¥–ø–∏—Å–∞—Ç—å—Å—è", url=f"https://t.me/neurogptpro")],
            [InlineKeyboardButton(text="‚úÖ –ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É", callback_data="check_subscription")]
        ]
    )

def pay_keyboard(amount: int, currency: str = "‚≠ê") -> InlineKeyboardMarkup:
    builder = InlineKeyboardBuilder()
    builder.button(text=f"üí≥ –û–ø–ª–∞—Ç–∏—Ç—å {amount} {currency}", pay=True)
    builder.button(text="üÜò –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"tg://user?username={PAYMENT_ADMIN[1:]}")
    builder.button(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="home")
    builder.button(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")
    builder.adjust(1, 2, 1)
    return builder.as_markup()

def balance_keyboard() -> InlineKeyboardMarkup:
    buttons = [
        [("üîÑ –û–±–Ω–æ–≤–∏—Ç—å", "refresh_balance"), ("üè† –ì–ª–∞–≤–Ω–æ–µ", "home")]
    ]
    return create_keyboard(buttons)

def referral_keyboard() -> InlineKeyboardMarkup:
    buttons = [
        [("üí∏ –í—ã–≤–µ—Å—Ç–∏ —Å—Ä–µ–¥—Å—Ç–≤–∞", "withdraw_referral")],
        [("üéÅ –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–º–æ–∫–æ–¥", "activate_promo")],
        [("üè† –ì–ª–∞–≤–Ω–æ–µ", "home")]
    ]
    return create_keyboard(buttons)

def model_select_keyboard() -> InlineKeyboardMarkup:
    buttons = [
        [("üñºÔ∏è –î–ª—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π", "image_model_select")],
        [("üìù –î–ª—è —Ç–µ–∫—Å—Ç–∞", "text_model_select")],
        [("üè† –ì–ª–∞–≤–Ω–æ–µ", "home")]
    ]
    return create_keyboard(buttons)

def image_models_keyboard(user: User) -> InlineKeyboardMarkup:
    buttons = []
    for key, model in IMAGE_MODELS.items():
        # –î–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –º–æ–¥–µ–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥—Ä—É–≥–æ–π —ç–º–æ–¥–∑–∏
        if user.image_model == key:
            buttons.append([(f"‚úÖ {model.name}", f"image_model_{key}")])
        else:
            buttons.append([(model.name, f"image_model_{key}")])
    
    buttons.append([("üîô –ù–∞–∑–∞–¥", "model_select")])
    return create_keyboard(buttons)

def text_models_keyboard(user: User) -> InlineKeyboardMarkup:
    buttons = []
    for key, model in TEXT_MODELS.items():
        if model.premium_only and not user.is_premium:
            # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–µ–º–∏—É–º –º–æ–¥–µ–ª–∏, –Ω–æ —Å –∏–∫–æ–Ω–∫–æ–π –∑–∞–º–∫–∞
            buttons.append([(f"üîí {model.name} (–ø—Ä–µ–º–∏—É–º)", "premium_required")])
        else:
            if user.text_model == key:
                buttons.append([(f"‚úÖ {model.name}", f"text_model_{key}")])
            else:
                buttons.append([(model.name, f"text_model_{key}")])
    
    buttons.append([("üîô –ù–∞–∑–∞–¥", "model_select")])
    return create_keyboard(buttons)

# ===================== –ê–ù–ò–ú–ê–¶–ò–ò –ò –£–í–ï–î–û–ú–õ–ï–ù–ò–Ø =====================
async def animate_loading(message: Message, text: str, duration: float = 1.5) -> Message:
    msg = await message.answer(f"‚è≥ {text}")
    await asyncio.sleep(duration)
    return msg

async def animate_error(message: Message, text: str) -> Message:
    msg = await message.answer(f"‚ùå {text}")
    await asyncio.sleep(1)
    return msg

async def animate_success(message: Message, text: str) -> Message:
    msg = await message.answer(f"‚úÖ {text}")
    await asyncio.sleep(1)
    return msg

async def animate_progress(message: Message, text: str, progress: float):
    bar_length = 10
    filled = int(progress * bar_length)
    bar = 'üü©' * filled + '‚¨úÔ∏è' * (bar_length - filled)
    try:
        await message.edit_text(f"‚è≥ {text}\n{bar} {int(progress*100)}%")
    except TelegramBadRequest:
        pass

async def safe_edit_message(
    callback: CallbackQuery, 
    text: str, 
    reply_markup: InlineKeyboardMarkup = None, 
    parse_mode: str = "HTML"
):
    try:
        if callback.message.text:
            await callback.message.edit_text(text, reply_markup=reply_markup, parse_mode=parse_mode)
        elif callback.message.caption:
            await callback.message.edit_caption(caption=text, reply_markup=reply_markup, parse_mode=parse_mode)
        else:
            await callback.message.answer(text, reply_markup=reply_markup, parse_mode=parse_mode)
    except TelegramBadRequest as e:
        logger.warning(f"Message edit failed: {e}, sending new message")
        await callback.message.answer(text, reply_markup=reply_markup, parse_mode=parse_mode)

# ===================== –§–û–†–ú–ê–¢–ò–†–û–í–ê–ù–ò–ï =====================
def format_balance(user: User) -> str:
    user.check_premium_status()
    
    daily_status = "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω" if user.can_claim_daily() else "‚ùå –£–∂–µ –ø–æ–ª—É—á–µ–Ω"
    premium_status = "–ê–∫—Ç–∏–≤–µ–Ω" if user.is_premium else "–ù–µ–∞–∫—Ç–∏–≤–µ–Ω"
    
    text = (
        f"üí∞ <b>–í–ê–® –ë–ê–õ–ê–ù–°</b>\n"
        f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        f"‚≠ê –ó–≤–µ–∑–¥—ã: {hbold(user.stars)}\n"
        f"üéÅ –ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å: {daily_status}\n"
        f"üíé –ü—Ä–µ–º–∏—É–º: {premium_status}\n"
        f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
    )
    
    if user.is_premium and user.premium_expiry:
        days_left = max(0, int((user.premium_expiry - time.time()) / (24 * 3600)))
        text += f"üíé –ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–µ–Ω! –û—Å—Ç–∞–ª–æ—Å—å: {days_left} –¥–Ω–µ–π\n"
    elif user.is_premium:
        text += f"üíé –ü—Ä–µ–º–∏—É–º –∞–∫—Ç–∏–≤–µ–Ω (–ù–∞–≤—Å–µ–≥–¥–∞)\n"
    else:
        text += (
            f"‚ÑπÔ∏è –ü—Ä–µ–º–∏—É–º –¥–∞–µ—Ç –±–µ–∑–ª–∏–º–∏—Ç–Ω—É—é –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n"
            f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        )
        
    return text

def format_premium_info(user: User) -> str:
    if user.is_premium:
        status = "–û—Å—Ç–∞–ª–æ—Å—å: "
        if user.premium_expiry:
            days_left = max(0, int((user.premium_expiry - time.time()) / (24 * 3600)))
            status += f"{days_left} –¥–Ω–µ–π"
        else:
            status = "–ù–ê–í–°–ï–ì–î–ê"
        
        text = (
            f"üíé <b>–ü–†–ï–ú–ò–£–ú –ü–û–î–ü–ò–°–ö–ê –ê–ö–¢–ò–í–ù–ê!</b>\n"
            f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
            f"‚è≥ {status}\n\n"
            f"‚ú® <b>–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:</b>\n"
            f"‚Ä¢ üé® –ë–µ–∑–ª–∏–º–∏—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n"
            f"‚Ä¢ üë§ –ë–µ–∑–ª–∏–º–∏—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∞–≤–∞—Ç–∞—Ä–æ–≤\n"
            f"‚Ä¢ üñºÔ∏è –ë–µ–∑–ª–∏–º–∏—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–æ–≥–æ—Ç–∏–ø–æ–≤\n"
            f"‚Ä¢ üìù –ë–µ–∑–ª–∏–º–∏—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞\n"
            f"‚Ä¢ üß† –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n"
            f"‚Ä¢ üñºÔ∏è –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–æ 8 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤\n"
            f"‚Ä¢ ü§ñ –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–µ –º–æ–¥–µ–ª–∏ –ò–ò\n"
            f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        )
    else:
        text = (
            f"üíé <b>–ü–†–ï–ú–ò–£–ú –ü–û–î–ü–ò–°–ö–ê</b>\n"
            f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
            f"‚ú® <b>–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:</b>\n"
            f"‚Ä¢ üé® –ë–µ–∑–ª–∏–º–∏—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n"
            f"‚Ä¢ üë§ –ë–µ–∑–ª–∏–º–∏—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∞–≤–∞—Ç–∞—Ä–æ–≤\n"
            f"‚Ä¢ üñºÔ∏è –ë–µ–∑–ª–∏–º–∏—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–æ–≥–æ—Ç–∏–ø–æ–≤\n"
            f"‚Ä¢ üìù –ë–µ–∑–ª–∏–º–∏—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞\n"
            f"‚Ä¢ üß† –†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç\n"
            f"‚Ä¢ üñºÔ∏è –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –¥–æ 8 –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤\n"
            f"‚Ä¢ ü§ñ –≠–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–µ –º–æ–¥–µ–ª–∏ –ò–ò\n\n"
            f"üí° <b>–î–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ –ø—Ä–µ–º–∏—É–º–∞ –ø—Ä–∏–æ–±—Ä–µ—Ç–∏—Ç–µ –ø–æ–¥–ø–∏—Å–∫—É –≤ –º–∞–≥–∞–∑–∏–Ω–µ</b>\n"
            f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        )
    return text

def format_generation_cost(model: GenerationModel, base_cost: int, is_premium: bool) -> str:
    cost = int(base_cost * model.cost_multiplier)
    if is_premium:
        return "üíé –ë–µ–∑–ª–∏–º–∏—Ç (–ø—Ä–µ–º–∏—É–º)"
    return f"üíé –°—Ç–æ–∏–º–æ—Å—Ç—å: {cost} ‚≠ê"

def format_model_info(model: GenerationModel) -> str:
    return f"{model.name}\n{model.description}\nüí∞ –ú–Ω–æ–∂–∏—Ç–µ–ª—å —Å—Ç–æ–∏–º–æ—Å—Ç–∏: {model.cost_multiplier}x"

# ===================== –û–ë–†–ê–ë–û–¢–ö–ê –ú–ï–ù–Æ =====================
async def handle_text_gen(callback: CallbackQuery, user: User):
    model = TEXT_MODELS[user.text_model]
    base_cost = int(TEXT_COST_PER_100_WORDS * model.cost_multiplier)
    cost_text = format_generation_cost(model, TEXT_COST_PER_100_WORDS, user.is_premium)
    
    await safe_edit_message(
        callback, 
        "üìù <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        f"ü§ñ –ú–æ–¥–µ–ª—å: {model.name}\n\n"
        "üîç <b>–û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à –∑–∞–ø—Ä–æ—Å:</b>\n"
        f"{cost_text}\n"
        f"‚ö†Ô∏è –ú–∞–∫—Å–∏–º—É–º {MAX_PROMPT_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤\n"
        f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
        reply_markup=cancel_keyboard()
    )

async def show_menu(callback: CallbackQuery, user: User):
    user.update_interaction()
    logger.info(f"Showing menu for state: {user.state}")
    
    menu_handlers = {
        UserState.MAIN_MENU: handle_main_menu,
        UserState.GENERATE_MENU: handle_generate_menu,
        UserState.PROFILE_MENU: handle_profile_menu,
        UserState.IMAGE_GEN: handle_image_gen,
        UserState.TEXT_GEN: handle_text_gen,  # –î–û–ë–ê–í–õ–ï–ù–û
        UserState.AVATAR_GEN: handle_avatar_gen,
        UserState.LOGO_GEN: handle_logo_gen,
        UserState.PREMIUM_INFO: handle_premium_info,
        UserState.SHOP: handle_shop,
        UserState.SUPPORT: handle_support,
        UserState.REFERRAL: handle_referral,
        UserState.ACTIVATE_PROMO: handle_activate_promo,
        UserState.BALANCE: handle_balance,
        UserState.IMAGE_COUNT_SELECT: handle_image_count_select,
        UserState.IMAGE_MODEL_SELECT: handle_image_model_select,
        UserState.MODEL_SELECT: handle_model_select,
        UserState.TEXT_MODEL_SELECT: handle_text_model_select
    }
    
    handler = menu_handlers.get(user.state)
    if handler:
        logger.info(f"Calling handler for state {user.state}")
        await handler(callback, user)
    else:
        logger.warning(f"No handler for state {user.state}")
        await callback.message.answer("üè† <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê", reply_markup=main_keyboard(user))

async def handle_main_menu(callback: CallbackQuery, user: User):
    await safe_edit_message(
        callback,
        "üåü <b>–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=main_keyboard(user)
    )

async def handle_generate_menu(callback: CallbackQuery, user: User):
    await safe_edit_message(
        callback,
        "üöÄ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø:",
        reply_markup=generate_menu_keyboard()
    )

async def handle_profile_menu(callback: CallbackQuery, user: User):
    await safe_edit_message(
        callback,
        "üë§ <b>–í–∞—à –ø—Ä–æ—Ñ–∏–ª—å</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=profile_menu_keyboard()
    )

async def handle_image_gen(callback: CallbackQuery, user: User):
    model = IMAGE_MODELS[user.image_model]
    base_cost = int(IMAGE_COST * model.cost_multiplier)
    cost_text = format_generation_cost(model, IMAGE_COST, user.is_premium)
    
    await safe_edit_message(
        callback, 
        "üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        f"ü§ñ –ú–æ–¥–µ–ª—å: {model.name}\n\n"
        "üîç <b>–û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:</b>\n"
        "–ü—Ä–∏–º–µ—Ä—ã:\n"
        "‚Ä¢ –ö–æ—Å–º–∏—á–µ—Å–∫–∏–π –∫–æ—Ä–∞–±–ª—å –≤ —Å—Ç–∏–ª–µ –∫–∏–±–µ—Ä–ø–∞–Ω–∫\n"
        "‚Ä¢ –†–µ–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π –ø–æ—Ä—Ç—Ä–µ—Ç –∫–æ—Ç–∞\n\n"
        f"{cost_text}\n"
        f"‚ö†Ô∏è –ú–∞–∫—Å–∏–º—É–º {MAX_PROMPT_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤\n"
        f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
        reply_markup=cancel_keyboard()
    )

async def handle_image_count_select(callback: CallbackQuery, user: User):
    await safe_edit_message(
        callback,
        "üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è (–ø—Ä–µ–º–∏—É–º)</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        f"ü§ñ –ú–æ–¥–µ–ª—å: {IMAGE_MODELS[user.image_model].name}\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤:",
        reply_markup=image_count_keyboard()
    )

async def handle_avatar_gen(callback: CallbackQuery, user: User):
    model = IMAGE_MODELS[user.image_model]
    base_cost = int(AVATAR_COST * model.cost_multiplier)
    cost_text = format_generation_cost(model, AVATAR_COST, user.is_premium)
    
    await safe_edit_message(
        callback, 
        "üë§ <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∞–≤–∞—Ç–∞—Ä–∞</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        f"ü§ñ –ú–æ–¥–µ–ª—å: {model.name}\n\n"
        "üîç <b>–û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∞–≤–∞—Ç–∞—Ä–∞:</b>\n"
        "–ü—Ä–∏–º–µ—Ä—ã:\n"
        "‚Ä¢ –î–µ–≤—É—à–∫–∞ —Å —Ä–æ–∑–æ–≤—ã–º–∏ –≤–æ–ª–æ—Å–∞–º–∏\n"
        "‚Ä¢ –ú—É–∂—á–∏–Ω–∞ –≤ —Å—Ç–∏–ª–µ —Å–∞–º—É—Ä–∞—è\n\n"
        f"{cost_text}\n"
        f"‚ö†Ô∏è –ú–∞–∫—Å–∏–º—É–º {MAX_PROMPT_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤\n"
        f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
        reply_markup=cancel_keyboard()
    )

async def handle_logo_gen(callback: CallbackQuery, user: User):
    model = IMAGE_MODELS[user.image_model]
    base_cost = int(LOGO_COST * model.cost_multiplier)
    cost_text = format_generation_cost(model, LOGO_COST, user.is_premium)
    
    await safe_edit_message(
        callback, 
        "üñºÔ∏è <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ª–æ–≥–æ—Ç–∏–ø–∞</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        f"ü§ñ –ú–æ–¥–µ–ª—å: {model.name}\n\n"
        "üîç <b>–û—Ç–ø—Ä–∞–≤—å—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ –ª–æ–≥–æ—Ç–∏–ø–∞:</b>\n"
        "–ü—Ä–∏–º–µ—Ä—ã:\n"
        "‚Ä¢ –õ–æ–≥–æ –¥–ª—è IT –∫–æ–º–ø–∞–Ω–∏–∏\n"
        "‚Ä¢ –ó–Ω–∞—á–æ–∫ –¥–ª—è –∫–∞—Ñ–µ\n\n"
        f"{cost_text}\n"
        f"‚ö†Ô∏è –ú–∞–∫—Å–∏–º—É–º {MAX_PROMPT_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤\n"
        f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
        reply_markup=cancel_keyboard()
    )

async def handle_premium_info(callback: CallbackQuery, user: User):
    text = format_premium_info(user)
    reply_markup = premium_keyboard() if not user.is_premium else home_keyboard()
    await safe_edit_message(callback, text, reply_markup=reply_markup)

async def handle_shop(callback: CallbackQuery, user: User):
    text = f"üõí <b>–ú–ê–ì–ê–ó–ò–ù</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n{format_balance(user)}\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n–í—ã–±–µ—Ä–∏—Ç–µ —Ç–æ–≤–∞—Ä:"
    await safe_edit_message(callback, text, reply_markup=shop_keyboard())

async def handle_support(callback: CallbackQuery, user: User):
    await safe_edit_message(
        callback,
        "üÜò <b>–ü–û–î–î–ï–†–ñ–ö–ê</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        f"‚Ä¢ –ü–æ –≤–æ–ø—Ä–æ—Å–∞–º: {PAYMENT_ADMIN}\n"
        "‚Ä¢ –ü–æ –æ–ø–ª–∞—Ç–µ: @telichko_a\n"
        "‚Ä¢ –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–∏—è: @telichko_a\n\n"
        "–ú—ã –æ—Ç–≤–µ—á–∞–µ–º –≤ —Ç–µ—á–µ–Ω–∏–µ 24 —á–∞—Å–æ–≤.\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
        reply_markup=home_keyboard()
    )

async def handle_referral(callback: CallbackQuery, user: User):
    referral_link = f"https://t.me/NeuroAlliance_bot?start={user.referral_code}"
    await safe_edit_message(
        callback,
        f"üë• <b>–†–ï–§–ï–†–ê–õ–¨–ù–ê–Ø –°–ò–°–¢–ï–ú–ê</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        f"üîó –í–∞—à–∞ —Å—Å—ã–ª–∫–∞:\n{hcode(referral_link)}\n"
        f"üíé –ó–∞ –ø—Ä–∏–≥–ª–∞—à–µ–Ω–Ω–æ–≥–æ:\n"
        f"‚Ä¢ –í—ã –ø–æ–ª—É—á–∞–µ—Ç–µ: {REFERRAL_BONUS} ‚≠ê\n"
        f"‚Ä¢ –î—Ä—É–≥ –ø–æ–ª—É—á–∞–µ—Ç: {START_BALANCE_STARS//2} ‚≠ê\n\n"
        f"üí∞ –†–µ—Ñ–µ—Ä–∞–ª—å–Ω—ã–π –±–∞–ª–∞–Ω—Å: {hbold(user.referral_balance)} üíé\n"
        f"‚ö†Ô∏è –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –≤—ã–≤–æ–¥: {WITHDRAW_MIN} üíé\n"
        f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
        reply_markup=referral_keyboard()
    )

async def handle_activate_promo(callback: CallbackQuery, user: User):
    await safe_edit_message(
        callback,
        "üéÅ <b>–ê–ö–¢–ò–í–ê–¶–ò–Ø –ü–†–û–ú–û–ö–û–î–ê</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        "üîë –í–≤–µ–¥–∏—Ç–µ –ø—Ä–æ–º–æ–∫–æ–¥:",
        reply_markup=cancel_keyboard()
    )

async def handle_balance(callback: CallbackQuery, user: User):
    text = format_balance(user)
    await safe_edit_message(callback, text, reply_markup=balance_keyboard())

async def handle_image_model_select(callback: CallbackQuery, user: User):
    text = "ü§ñ <b>–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
    
    # –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π
    model_list = []
    for key, model in IMAGE_MODELS.items():
        selected = " ‚úÖ" if user.image_model == key else ""
        model_list.append(f"{model.name}{selected}")
    
    text += "\n".join(model_list)
    await safe_edit_message(callback, text, reply_markup=image_models_keyboard(user))

async def handle_model_select(callback: CallbackQuery, user: User):
    current_image_model = IMAGE_MODELS[user.image_model].name
    current_text_model = TEXT_MODELS[user.text_model].name
    
    text = (
        "ü§ñ <b>–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –º–æ–¥–µ–ª–∏</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        f"üñºÔ∏è –¢–µ–∫—É—â–∞—è –º–æ–¥–µ–ª—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π: {current_image_model}\n"
        f"üìù –¢–µ–∫—É—â–∞—è —Ç–µ–∫—Å—Ç–æ–≤–∞—è –º–æ–¥–µ–ª—å: {current_text_model}\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    )
    
    await safe_edit_message(callback, text, reply_markup=model_select_keyboard())

async def handle_text_model_select(callback: CallbackQuery, user: User):
    text = "ü§ñ <b>–í—ã–±–µ—Ä–∏—Ç–µ –º–æ–¥–µ–ª—å –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ç–µ–∫—Å—Ç–∞</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
    
    # –°–æ–∑–¥–∞–µ–º —Å–ø–∏—Å–æ–∫ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π —Å —É—á–µ—Ç–æ–º –ø—Ä–µ–º–∏—É–º —Å—Ç–∞—Ç—É—Å–∞
    model_list = []
    for key, model in TEXT_MODELS.items():
        if model.premium_only and not user.is_premium:
            continue
            
        selected = " ‚úÖ" if user.text_model == key else ""
        model_list.append(f"{model.name}{selected}")
    
    text += "\n".join(model_list)
    
    # –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–µ–º–∏—É–º –º–æ–¥–µ–ª—è—Ö
    if any(model.premium_only for model in TEXT_MODELS.values()):
        text += "\n\nüîí –ü—Ä–µ–º–∏—É–º-–º–æ–¥–µ–ª–∏ –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ —Å –ø–æ–¥–ø–∏—Å–∫–æ–π"
    
    await safe_edit_message(callback, text, reply_markup=text_models_keyboard(user))

# ===================== –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–û–ú–ê–ù–î =====================
@dp.callback_query(F.data == "back")
async def back_handler(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    prev_menu = user.pop_menu()
    
    if prev_menu:
        user.state = prev_menu["state"]
        await show_menu(callback, user)
    else:
        user.state = UserState.MAIN_MENU
        await show_menu(callback, user)
    
    await callback.answer()

@dp.callback_query(F.data == "home")
async def home_handler(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.state = UserState.MAIN_MENU
    user.menu_stack = []
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "cancel")
async def cancel_handler(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.state = UserState.MAIN_MENU
    user.menu_stack = []
    await callback.message.answer("‚ùå –î–µ–π—Å—Ç–≤–∏–µ –æ—Ç–º–µ–Ω–µ–Ω–æ", reply_markup=main_keyboard(user))
    await callback.answer()

@dp.callback_query(F.data == "check_subscription")
async def check_subscription_handler(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    
    if await check_subscription(user.user_id):
        user.has_subscribed = True
        user.mark_modified()
        
        if user.pending_referral and not user.referral_used:
            await process_referral(user, user.pending_referral)
            user.pending_referral = None
            user.referral_used = True
        
        await callback.message.delete()
        await bot.send_message(
            user.user_id,
            "‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!",
            reply_markup=main_keyboard(user)
        )
    else:
        await callback.answer("‚ùå –í—ã –≤—Å–µ –µ—â–µ –Ω–µ –ø–æ–¥–ø–∏—Å–∞–Ω—ã! –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–ø–∏—à–∏—Ç–µ—Å—å.", show_alert=True)
    
    await callback.answer()

@dp.callback_query(F.data == "daily_bonus")
async def daily_bonus_handler(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    if user.can_claim_daily():
        bonus = user.claim_daily_bonus()
        await callback.answer(f"üéÅ –ü–æ–ª—É—á–µ–Ω–æ {bonus} –∑–≤—ë–∑–¥!", show_alert=True)
        text = format_balance(user)
        await safe_edit_message(callback, text, reply_markup=balance_keyboard())
        await save_db()
    else:
        last_date = datetime.datetime.fromtimestamp(user.last_daily_bonus).strftime("%d.%m.%Y")
        await callback.answer(f"‚ùå –í—ã —É–∂–µ –ø–æ–ª—É—á–∞–ª–∏ –±–æ–Ω—É—Å —Å–µ–≥–æ–¥–Ω—è ({last_date})", show_alert=True)

@dp.callback_query(F.data == "generate_menu")
async def process_generate_menu(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.GENERATE_MENU
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "profile_menu")
async def process_profile_menu(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.PROFILE_MENU
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "premium_info")
async def premium_info(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.PREMIUM_INFO
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "gen_image")
async def process_gen_image(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    if user.is_premium:
        user.state = UserState.IMAGE_COUNT_SELECT
    else:
        user.state = UserState.IMAGE_GEN
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "gen_avatar")
async def process_gen_avatar(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.AVATAR_GEN
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "gen_logo")
async def process_gen_logo(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.LOGO_GEN
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "gen_text")
async def process_gen_text(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.TEXT_GEN
    user.mark_modified()
    
    model = TEXT_MODELS[user.text_model]
    base_cost = int(TEXT_COST_PER_100_WORDS * model.cost_multiplier)
    cost_text = format_generation_cost(model, TEXT_COST_PER_100_WORDS, user.is_premium)
    
    await safe_edit_message(
        callback, 
        "üìù <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ–∫—Å—Ç–∞</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        f"ü§ñ –ú–æ–¥–µ–ª—å: {model.name}\n\n"
        "üîç <b>–û—Ç–ø—Ä–∞–≤—å—Ç–µ –≤–∞—à –∑–∞–ø—Ä–æ—Å:</b>\n"
        f"{cost_text}\n"
        f"‚ö†Ô∏è –ú–∞–∫—Å–∏–º—É–º {MAX_PROMPT_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤\n"
        f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê",
        reply_markup=cancel_keyboard()
    )
    await callback.answer()

@dp.callback_query(F.data == "model_select")
async def process_model_select(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    logger.info(f"User {user.user_id} requested model selection")
    
    user.push_menu(user.state, {})
    user.state = UserState.MODEL_SELECT
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "image_model_select")
async def process_image_model_select(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    logger.info(f"User {user.user_id} selecting image model")
    
    user.push_menu(user.state, {})
    user.state = UserState.IMAGE_MODEL_SELECT
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "text_model_select")
async def process_text_model_select(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    logger.info(f"User {user.user_id} selecting text model")
    
    user.push_menu(user.state, {})
    user.state = UserState.TEXT_MODEL_SELECT
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data.startswith("image_model_"))
async def set_image_model(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    model_key = callback.data.split('_')[2]
    if model_key in IMAGE_MODELS:
        user.image_model = model_key
        user.mark_modified()
        model_name = IMAGE_MODELS[model_key].name
        await callback.answer(f"‚úÖ –í—ã–±—Ä–∞–Ω–∞ –º–æ–¥–µ–ª—å: {model_name}")
        
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ –º–æ–¥–µ–ª–µ–π
        user.state = UserState.MODEL_SELECT
        user.mark_modified()
        await show_menu(callback, user)
    else:
        await callback.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –º–æ–¥–µ–ª—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π")
        logger.error(f"Unknown image model: {model_key}")

@dp.callback_query(F.data.startswith("text_model_"))
async def set_text_model(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    model_key = callback.data.split('_')[2]
    model = TEXT_MODELS.get(model_key)
    
    if not model:
        await callback.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è —Ç–µ–∫—Å—Ç–æ–≤–∞—è –º–æ–¥–µ–ª—å")
        logger.error(f"Unknown text model: {model_key}")
        return
    
    if model.premium_only and not user.is_premium:
        await callback.answer("‚ùå –¢–æ–ª—å–∫–æ –¥–ª—è –ø—Ä–µ–º–∏—É–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π!", show_alert=True)
        return
    
    user.text_model = model_key
    user.mark_modified()
    await callback.answer(f"‚úÖ –í—ã–±—Ä–∞–Ω–∞ –º–æ–¥–µ–ª—å: {model.name}")
    
    # –í–æ–∑–≤—Ä–∞—â–∞–µ–º—Å—è –≤ –º–µ–Ω—é –≤—ã–±–æ—Ä–∞ –º–æ–¥–µ–ª–µ–π
    user.state = UserState.MODEL_SELECT
    user.mark_modified()
    await show_menu(callback, user)

@dp.callback_query(F.data == "premium_required")
async def premium_required_handler(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    text = (
        "üîí <b>–ü—Ä–µ–º–∏—É–º-–º–æ–¥–µ–ª—å</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        "–≠—Ç–∞ –º–æ–¥–µ–ª—å –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –ø—Ä–µ–º–∏—É–º-–ø–æ–¥–ø–∏—Å–∫–æ–π.\n\n"
        "üíé –ü—Ä–µ–º–∏—É–º-–ø–æ–¥–ø–∏—Å–∫–∞ –¥–∞–µ—Ç –¥–æ—Å—Ç—É–ø:\n"
        "- –ö —ç–∫—Å–∫–ª—é–∑–∏–≤–Ω—ã–º –º–æ—â–Ω—ã–º –º–æ–¥–µ–ª—è–º\n"
        "- –ë–µ–∑–ª–∏–º–∏—Ç–Ω–æ–π –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞\n"
        "- –ü—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–µ –∑–∞–ø—Ä–æ—Å–æ–≤\n\n"
        "–û—Ñ–æ—Ä–º–∏—Ç—å –ø—Ä–µ–º–∏—É–º –º–æ–∂–Ω–æ –≤ –º–∞–≥–∞–∑–∏–Ω–µ."
    )
    
    await callback.answer("‚ùå –¢—Ä–µ–±—É–µ—Ç—Å—è –ø—Ä–µ–º–∏—É–º-–ø–æ–¥–ø–∏—Å–∫–∞", show_alert=True)
    await safe_edit_message(callback, text, reply_markup=premium_keyboard())

@dp.callback_query(F.data.startswith("img_count_"))
async def process_image_count(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    count = int(callback.data.split('_')[2])
    user.image_count = count
    user.mark_modified()
    user.push_menu(user.state, {})
    user.state = UserState.IMAGE_GEN
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "balance_info")
async def show_balance(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.BALANCE
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "refresh_balance")
async def refresh_balance(callback: CallbackQuery):
    await show_balance(callback)

@dp.callback_query(F.data == "shop")
async def shop(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    user.push_menu(user.state, {})
    user.state = UserState.SHOP
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "referral_info")
async def referral_info(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.REFERRAL
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "withdraw_referral")
async def withdraw_referral(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    amount = user.referral_balance
    if amount < WITHDRAW_MIN:
        await callback.answer(
            f"‚ùå –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞: {WITHDRAW_MIN} üíé\n"
            f"–í–∞—à –±–∞–ª–∞–Ω—Å: {amount} üíé",
            show_alert=True
        )
        return
    
    user.stars += amount
    user.referral_balance = 0
    user.mark_modified()
    
    await callback.answer(f"‚úÖ {amount} üíé –ø–µ—Ä–µ–≤–µ–¥–µ–Ω—ã –Ω–∞ –±–∞–ª–∞–Ω—Å!")
    await show_menu(callback, user)
    await save_db()

@dp.callback_query(F.data.startswith("buy_"))
async def process_buy(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    # –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ: –æ–±—ä–µ–¥–∏–Ω—è–µ–º –≤—Å–µ —á–∞—Å—Ç–∏ –ø–æ—Å–ª–µ –ø–µ—Ä–≤–æ–≥–æ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è
    item = '_'.join(callback.data.split('_')[1:])
    
    items = {
        "stars30": {
            "title": "30 –ó–≤–µ–∑–¥",
            "description": "–ü–∞–∫–µ—Ç –∑–≤–µ–∑–¥ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞",
            "currency": "XTR",
            "price": 30,
            "stars": 30
        },
        "stars50": {
            "title": "50 –ó–≤–µ–∑–¥",
            "description": "–ü–∞–∫–µ—Ç –∑–≤–µ–∑–¥",
            "currency": "XTR",
            "price": 50,
            "stars": 50
        },
        "stars150": {
            "title": "150 –ó–≤–µ–∑–¥",
            "description": "–ë–æ–ª—å—à–æ–π –ø–∞–∫–µ—Ç –∑–≤–µ–∑–¥",
            "currency": "XTR",
            "price": 150,
            "stars": 150
        },
        "stars500": {
            "title": "500 –ó–≤–µ–∑–¥",
            "description": "–û–≥—Ä–æ–º–Ω—ã–π –ø–∞–∫–µ—Ç –∑–≤–µ–∑–¥",
            "currency": "XTR",
            "price": 500,
            "stars": 500
        },
        "premium_month": {
            "title": "–ü—Ä–µ–º–∏—É–º 1 –º–µ—Å—è—Ü",
            "description": "–ü—Ä–µ–º–∏—É–º –¥–æ—Å—Ç—É–ø –Ω–∞ 30 –¥–Ω–µ–π",
            "currency": "XTR",
            "price": 600,
            "premium": True,
            "expiry": time.time() + 30 * 24 * 3600
        },
        "premium_forever": {
            "title": "–ü—Ä–µ–º–∏—É–º –Ω–∞–≤—Å–µ–≥–¥–∞",
            "description": "–ü–æ—Å—Ç–æ—è–Ω–Ω—ã–π –ø—Ä–µ–º–∏—É–º –¥–æ—Å—Ç—É–ø",
            "currency": "XTR",
            "price": 1999,
            "premium": True,
            "expiry": None
        },
    }
    
    if item not in items:
        await callback.answer(f"‚ùå –¢–æ–≤–∞—Ä –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω: {item}", show_alert=True)
        return
    
    product = items[item]
    
    await callback.message.answer_invoice(
        title=product["title"],
        description=product["description"],
        provider_token=PAYMENT_PROVIDER_TOKEN,
        currency=product["currency"],
        prices=[LabeledPrice(label=product["title"], amount=product["price"])],
        payload=item,
        need_name=False,
        need_phone_number=False,
        need_email=False,
        need_shipping_address=False,
        is_flexible=False,
        reply_markup=InlineKeyboardMarkup(inline_keyboard=[
            [InlineKeyboardButton(text="üí≥ –û–ø–ª–∞—Ç–∏—Ç—å", pay=True)],
            [InlineKeyboardButton(text="üÜò –ü–æ–¥–¥–µ—Ä–∂–∫–∞", url=f"tg://user?username={PAYMENT_ADMIN[1:]}")],
            [InlineKeyboardButton(text="üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="home")],
            [InlineKeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞", callback_data="cancel")]
        ])
    )
    await callback.answer()

@dp.callback_query(F.data == "support")
async def support_handler(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.SUPPORT
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "activate_promo")
async def activate_promo(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.ACTIVATE_PROMO
    user.mark_modified()
    await show_menu(callback, user)
    await callback.answer()

@dp.callback_query(F.data == "improve_image")
async def improve_image(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.IMAGE_IMPROVE
    user.mark_modified()
    
    if not user.last_image_prompt:
        await callback.answer("‚ùå –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö", show_alert=True)
        return
    
    cost = 0 if user.is_premium else IMPROVE_COST
    
    if not user.is_premium and user.stars < cost:
        await callback.answer(
            f"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–≤—ë–∑–¥!\n–ù—É–∂–Ω–æ: {cost} ‚≠ê\n–í–∞—à –±–∞–ª–∞–Ω—Å: {user.stars}",
            show_alert=True
        )
        return
    
    try:
        await callback.message.edit_reply_markup(reply_markup=None)
    except:
        pass
    
    processing_msg = await callback.message.answer("ü™Ñ –£–ª—É—á—à–∞—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ...")
    
    try:
        improved_prompt = await improve_prompt(user.last_image_prompt)
        logger.info(f"Improved prompt: {user.last_image_prompt} -> {improved_prompt}")
        user.last_image_prompt = improved_prompt
        user.mark_modified()
        
        if not user.is_premium:
            user.stars -= cost
            user.mark_modified()
        
        if detect_language(improved_prompt) != 'en':
            translated_prompt = await translate_to_english(improved_prompt)
        else:
            translated_prompt = improved_prompt

        encoded_prompt = urllib.parse.quote(translated_prompt)
        image_url = f"{IMAGE_URL}{encoded_prompt}?nologo=true"
        
        await processing_msg.delete()
        
        caption = trim_caption(
            f"‚ú® <b>–£–ª—É—á—à–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
            f"ü§ñ –ú–æ–¥–µ–ª—å: {IMAGE_MODELS[user.image_model].name}\n"
            f"{'üíé –ë–µ–∑–ª–∏–º–∏—Ç (–ø—Ä–µ–º–∏—É–º)' if user.is_premium else f'üíé –°—Ç–æ–∏–º–æ—Å—Ç—å: {cost} ‚≠ê'}\n"
            f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        )
        
        result = await safe_send_photo(
            callback.message,
            image_url,
            caption,
            image_options_keyboard(user)
        )
        user.last_image_url = result.photo[-1].file_id
        user.mark_modified()
    except Exception as e:
        logger.error(f"Improve image error: {e}")
        await processing_msg.edit_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–ª—É—á—à–µ–Ω–∏–∏")
    finally:
        await save_db()

@dp.callback_query(F.data == "regenerate_image")
async def regenerate_image(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    if user.is_premium:
        user.state = UserState.IMAGE_COUNT_SELECT
    else:
        user.state = UserState.IMAGE_GEN
    user.mark_modified()
    await callback.answer("üîÑ –í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–Ω–æ–≤–æ")

@dp.callback_query(F.data == "regenerate_avatar")
async def regenerate_avatar(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.AVATAR_GEN
    user.mark_modified()
    await callback.answer("üîÑ –í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–Ω–æ–≤–æ")

@dp.callback_query(F.data == "regenerate_logo")
async def regenerate_logo(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.LOGO_GEN
    user.mark_modified()
    await callback.answer("üîÑ –í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –∑–∞–Ω–æ–≤–æ")

@dp.callback_query(F.data == "regenerate_text")
async def regenerate_text(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.push_menu(user.state, {})
    user.state = UserState.TEXT_GEN
    user.mark_modified()
    await callback.answer("üîÑ –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å")

@dp.callback_query(F.data == "extend_text")
async def extend_text(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    if user.last_text:
        user.push_menu(user.state, {})
        user.state = UserState.TEXT_GEN
        user.mark_modified()
        await callback.message.answer("üìù –í–≤–µ–¥–∏—Ç–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –¥–µ—Ç–∞–ª–∏:")
    else:
        await callback.answer("‚ùå –ù–µ—Ç —Ç–µ–∫—Å—Ç–∞", show_alert=True)

@dp.callback_query(F.data == "rephrase_text")
async def rephrase_text(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    if user.last_text:
        user.push_menu(user.state, {})
        user.state = UserState.TEXT_GEN
        user.mark_modified()
        await callback.message.answer("‚úçÔ∏è –ö–∞–∫ –ø–µ—Ä–µ—Ñ—Ä–∞–∑–∏—Ä–æ–≤–∞—Ç—å?")
    else:
        await callback.answer("‚ùå –ù–µ—Ç —Ç–µ–∫—Å—Ç–∞", show_alert=True)

@dp.callback_query(F.data == "clear_context")
async def clear_context(callback: CallbackQuery):
    user = await get_user(callback.from_user.id)
    if not await ensure_subscription(callback, user):
        return
    
    user.clear_context()
    await callback.answer("üßπ –ö–æ–Ω—Ç–µ–∫—Å—Ç –æ—á–∏—â–µ–Ω!", show_alert=True)
    
    # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
    text = (
        "üìù <b>–ö–æ–Ω—Ç–µ–∫—Å—Ç –æ—á–∏—â–µ–Ω</b>\n"
        "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        "–ò—Å—Ç–æ—Ä–∏—è –¥–∏–∞–ª–æ–≥–∞ –±—ã–ª–∞ —Å–±—Ä–æ—à–µ–Ω–∞.\n"
        "–°–ª–µ–¥—É—é—â–∏–π –∑–∞–ø—Ä–æ—Å –±—É–¥–µ—Ç –æ–±—Ä–∞–±–æ—Ç–∞–Ω –±–µ–∑ —É—á–µ—Ç–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π."
    )
    await safe_edit_message(callback, text, reply_markup=text_options_keyboard(user))

# ===================== –ü–†–û–í–ï–†–ö–ê –ü–û–î–ü–ò–°–ö–ò =====================
async def check_subscription(user_id: int) -> bool:
    if user_id == ADMIN_ID:
        return True
        
    try:
        member = await bot.get_chat_member(chat_id=CHANNEL_ID, user_id=user_id)
        logger.info(f"User {user_id} status: {member.status}")
        
        allowed_statuses = [
            ChatMemberStatus.CREATOR,
            ChatMemberStatus.ADMINISTRATOR,
            ChatMemberStatus.MEMBER
        ]
        
        return member.status in allowed_statuses
    except TelegramBadRequest as e:
        if "bot is not a member" in str(e).lower():
            logger.critical("‚ùå –ë–û–¢ –ù–ï –Ø–í–õ–Ø–ï–¢–°–Ø –ê–î–ú–ò–ù–ò–°–¢–†–ê–¢–û–†–û–ú –ö–ê–ù–ê–õ–ê! ‚ùå")
            logger.critical("–î–æ–±–∞–≤—å—Ç–µ –±–æ—Ç–∞ –∫–∞–∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞ –≤ –∫–∞–Ω–∞–ª –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ–¥–ø–∏—Å–æ–∫")
        else:
            logger.error(f"Telegram error: {e}")
        return False
    except Exception as e:
        logger.error(f"Subscription check error: {e}")
        return False

async def ensure_subscription(target: Union[CallbackQuery, Message], user: User) -> bool:
    if user.user_id == ADMIN_ID:
        return True
        
    subscribed = await check_subscription(user.user_id)
    
    if subscribed:
        user.has_subscribed = True
        user.mark_modified()
        
        if user.pending_referral and not user.referral_used:
            await process_referral(user, user.pending_referral)
            user.pending_referral = None
            user.referral_used = True
            
        return True
    
    logger.warning(f"User {user.user_id} is not subscribed to channel {CHANNEL_ID}")
    
    text = (
        "üì¢ –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª!\n"
        "üëâ https://t.me/neurogptpro üëà\n\n"
        "–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ"
    )
    
    if isinstance(target, CallbackQuery):
        await target.message.answer(text, reply_markup=subscribe_keyboard())
        await target.answer()
    else:
        await target.answer(text, reply_markup=subscribe_keyboard())
    
    return False

async def process_referral(user: User, ref_code: str):
    if ref_code != user.referral_code and ref_code in referral_codes and not user.referral_used:
        referrer_id = referral_codes[ref_code]
        
        if referrer_id != user.user_id and referrer_id in users_db:
            referrer = users_db[referrer_id]
            referrer.referral_balance += REFERRAL_BONUS
            referrer.stars += REFERRAL_BONUS
            referrer.mark_modified()
            
            user.invited_by = ref_code
            user.stars += START_BALANCE_STARS // 2
            user.referral_used = True
            user.mark_modified()
            
            try:
                await bot.send_message(
                    referrer_id, 
                    f"üéâ –ù–æ–≤—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ –≤–∞—à–µ–π —Å—Å—ã–ª–∫–µ! "
                    f"–í–∞—à –±–∞–ª–∞–Ω—Å –ø–æ–ø–æ–ª–Ω–µ–Ω –Ω–∞ {REFERRAL_BONUS} ‚≠ê"
                )
            except Exception:
                logger.warning(f"Failed to notify referrer {referrer_id}")

# ===================== –ì–ï–ù–ï–†–ê–¶–ò–Ø –ö–û–ù–¢–ï–ù–¢–ê =====================
async def generate_content(
    user: User,
    text: str,
    message: Message,
    content_type: str,
    base_cost: int,
    model: GenerationModel,
    options_keyboard: InlineKeyboardMarkup,
    prompt_field: str,
    url_field: str,
    description: str,
    example: str
):
    try:
        if not await ensure_subscription(message, user):
            return
            
        if len(text) > MAX_PROMPT_LENGTH:
            await animate_error(message, f"‚ö†Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç {MAX_PROMPT_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤")
            return
            
        setattr(user, prompt_field, text)
        user.last_text = ""
        user.mark_modified()
        user.update_interaction()
        
        processing_msg = await animate_loading(message, f"ü™Ñ –ì–µ–Ω–µ—Ä–∏—Ä—É—é {description}...")
        
        if detect_language(text) != 'en':
            translated_prompt = await translate_to_english(text)
            logger.info(f"Translated: {text} -> {translated_prompt}")
        else:
            translated_prompt = text
        
        enhanced_prompt = f"{translated_prompt}, {model.prompt}"
        
        cost = 0 if user.is_premium else int(base_cost * model.cost_multiplier)
        
        if not user.is_premium and user.stars < cost:
            await processing_msg.delete()
            await animate_error(
                message, 
                f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–≤—ë–∑–¥!</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
                f"‚≠ê –ù—É–∂–Ω–æ: {cost} ‚≠ê\n"
                f"‚≠ê –í–∞—à –±–∞–ª–∞–Ω—Å: {user.stars}\n\n"
                f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            )
            return
        
        # –î–ª—è –ø—Ä–µ–º–∏—É–º-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π —Å –Ω–µ—Å–∫–æ–ª—å–∫–∏–º–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è–º–∏
        if content_type == "image" and user.is_premium and user.image_count > 1:
            count = min(user.image_count, MAX_IMAGE_COUNT)
            images = []
            
            for i in range(count):
                variant_prompt = f"{enhanced_prompt} --variant {i+1}"
                encoded_prompt = urllib.parse.quote(variant_prompt)
                image_url = f"{IMAGE_URL}{encoded_prompt}?nologo=true"
                images.append(image_url)
            
            # –°–æ–∑–¥–∞–µ–º –º–µ–¥–∏–∞–≥—Ä—É–ø–ø—É
            media_group = []
            for i, img_url in enumerate(images):
                if i == 0:
                    caption = f"üé® <b>{count} –≤–∞—Ä–∏–∞–Ω—Ç–∞</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
                    caption += f"ü§ñ –ú–æ–¥–µ–ª—å: {model.name}\n"
                    caption += f"üíé –ë–µ–∑–ª–∏–º–∏—Ç (–ø—Ä–µ–º–∏—É–º)\n"
                    caption += f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
                else:
                    caption = ""
                
                media_group.append(InputMediaPhoto(
                    media=img_url,
                    caption=trim_caption(caption) if caption else ""
                ))
                
                await animate_progress(processing_msg, f"–ì–µ–Ω–µ—Ä–∞—Ü–∏—è {i+1}/{count}", (i+1)/count)
            
            await processing_msg.delete()
            sent_messages = await message.answer_media_group(media=media_group)
            setattr(user, url_field, sent_messages[0].photo[-1].file_id)
            
            # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –æ—Ç–¥–µ–ª—å–Ω—ã–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º
            await sent_messages[-1].answer(
                f"‚úÖ {description.capitalize()} –≥–æ—Ç–æ–≤—ã!",
                reply_markup=options_keyboard
            )
        
        else:  # –û–¥–Ω–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            encoded_prompt = urllib.parse.quote(enhanced_prompt)
            image_url = f"{IMAGE_URL}{encoded_prompt}?nologo=true"
            
            if not user.is_premium:
                user.stars -= cost
                user.mark_modified()
            
            caption_text = trim_caption(
                f"{description.capitalize()} <b>–ì–æ—Ç–æ–≤–æ!</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
                f"ü§ñ –ú–æ–¥–µ–ª—å: {model.name}\n"
                f"{'üíé –ë–µ–∑–ª–∏–º–∏—Ç (–ø—Ä–µ–º–∏—É–º)' if user.is_premium else f'üíé –°—Ç–æ–∏–º–æ—Å—Ç—å: {cost} ‚≠ê'}\n"
                f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            )
            
            await processing_msg.delete()
            result = await safe_send_photo(
                message,
                image_url,
                caption_text,
                options_keyboard
            )
            setattr(user, url_field, result.photo[-1].file_id)
            user.mark_modified()
            
            await animate_success(message, f"‚úÖ {description.capitalize()} –≥–æ—Ç–æ–≤!")
    except aiohttp.ClientError as e:
        logger.error(f"Network error: {e}")
        await animate_error(message, "‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–µ—Ç–∏, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ")
    except asyncio.TimeoutError:
        logger.error("Timeout during generation")
        await animate_error(message, "‚åõ –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")
    except Exception as e:
        logger.exception("Unhandled error in generation")
        await animate_error(message, f"‚õî –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}")
    finally:
        await save_db()

async def generate_text(user: User, text: str, message: Message):
    try:
        if not await ensure_subscription(message, user):
            return
            
        model = TEXT_MODELS[user.text_model]
        if model.premium_only and not user.is_premium:
            await animate_error(message, "‚ùå –≠—Ç–∞ –º–æ–¥–µ–ª—å –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è –ø—Ä–µ–º–∏—É–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π")
            return
            
        if len(text) > MAX_PROMPT_LENGTH:
            await animate_error(message, f"‚ö†Ô∏è –ü—Ä–µ–≤—ã—à–µ–Ω –ª–∏–º–∏—Ç {MAX_PROMPT_LENGTH} —Å–∏–º–≤–æ–ª–æ–≤")
            return
            
        user.last_text = text
        user.last_image_prompt = ""
        user.mark_modified()
        user.update_interaction()
        
        processing_msg = await animate_loading(message, "üß† –û–±—Ä–∞–±–∞—Ç—ã–≤–∞—é –∑–∞–ø—Ä–æ—Å...")
        
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ –¥–ª—è –ø—Ä–µ–º–∏—É–º-–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        if user.is_premium and not user.context:
            user.context = [
                {"role": "system", "content": SYSTEM_PROMPT}
            ]
        
        if user.is_premium:
            user.add_context("user", text)
            full_prompt = "\n".join([f"{msg['role']}: {msg['content']}" for msg in user.context])
        else:
            full_prompt = f"{SYSTEM_PROMPT}\n\n–ó–∞–ø—Ä–æ—Å: {text}"
        
        full_prompt = f"{model.prompt}\n\n{full_prompt}"
        full_prompt = truncate_prompt(full_prompt)
        
        await send_typing_effect(message.chat.id, duration=3)
        
        encoded_prompt = urllib.parse.quote(full_prompt)
        result = await fetch_with_retry(f"{TEXT_URL}{encoded_prompt}")
        
        if not result:
            raise Exception("–û—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")
        
        # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å –æ—á–∏—Å—Ç–∫–æ–π HTML
        formatted_result = format_code_blocks(result)
        
        input_words = count_words(text)
        output_words = count_words(formatted_result)
        total_words = input_words + output_words
        cost = (total_words // 100) + (1 if total_words % 100 > 0 else 0)
        cost = int(cost * model.cost_multiplier)
        
        if not user.is_premium and user.stars < cost:
            await processing_msg.delete()
            await animate_error(
                message, 
                f"‚ùå <b>–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∑–≤—ë–∑–¥!</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
                f"‚≠ê –ù—É–∂–Ω–æ: {cost} ‚≠ê\n"
                f"‚≠ê –í–∞—à –±–∞–ª–∞–Ω—Å: {user.stars}\n\n"
                f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
            )
            return
        
        if not user.is_premium:
            user.stars -= cost
            user.mark_modified()
        elif user.is_premium:
            # –î–æ–±–∞–≤–ª—è–µ–º –æ—Ç–≤–µ—Ç –∞—Å—Å–∏—Å—Ç–µ–Ω—Ç–∞ –≤ –∫–æ–Ω—Ç–µ–∫—Å—Ç
            user.add_context("assistant", result)
        
        await processing_msg.delete()
        
        # –†–∞–∑–¥–µ–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –Ω–∞ —á–∞—Å—Ç–∏
        messages = split_message(f"üìù <b>–†–µ–∑—É–ª—å—Ç–∞—Ç:</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n{formatted_result}")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ —á–∞—Å—Ç–∏, –∫—Ä–æ–º–µ –ø–æ—Å–ª–µ–¥–Ω–µ–π
        for msg_text in messages[:-1]:
            await message.answer(msg_text, parse_mode="HTML")
        
        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é —á–∞—Å—Ç—å
        last_msg = await message.answer(messages[-1], parse_mode="HTML")
        
        stats_text = f"‚úÖ <b>–ì–æ—Ç–æ–≤–æ!</b>\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        stats_text += f"ü§ñ –ú–æ–¥–µ–ª—å: {model.name}\n"
        
        if user.is_premium:
            stats_text += f"üíé –ë–µ–∑–ª–∏–º–∏—Ç (–ø—Ä–µ–º–∏—É–º)\n"
        else:
            stats_text += f"‚≠ê –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∑–≤—ë–∑–¥: {cost}\n"
            stats_text += f"‚≠ê –û—Å—Ç–∞—Ç–æ–∫: {user.stars}\n"
        
        stats_text += "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        
        await last_msg.answer(
            stats_text,
            reply_markup=text_options_keyboard(user)
        )
        
        await animate_success(message, "‚úÖ –¢–µ–∫—Å—Ç –≥–æ—Ç–æ–≤!")
    except TelegramBadRequest as e:
        logger.error(f"HTML formatting error: {e}")
        # –ü—ã—Ç–∞–µ–º—Å—è –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –±–µ–∑ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        await processing_msg.delete()
        await message.answer("‚ö†Ô∏è –û—à–∏–±–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è, –æ—Ç–ø—Ä–∞–≤–ª—è—é —Ç–µ–∫—Å—Ç –±–µ–∑ –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è:")
        await message.answer(result[:4000])
    except aiohttp.ClientError as e:
        logger.error(f"Network error: {e}")
        await animate_error(message, "‚ö†Ô∏è –û—à–∏–±–∫–∞ —Å–µ—Ç–∏, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ")
    except asyncio.TimeoutError:
        logger.error("Timeout during text generation")
        await animate_error(message, "‚åõ –¢–∞–π–º–∞—É—Ç –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏")
    except Exception as e:
        logger.exception("Unhandled error in text generation")
        await animate_error(message, f"‚õî –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {str(e)}")
    finally:
        await save_db()

async def process_promo_code(user: User, promo_code: str, message: Message):
    promo_code = promo_code.strip().upper()
    
    if promo_code == "FREESTARS":
        user.stars += 100
        text = "üéÅ –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω –ø—Ä–æ–º–æ–∫–æ–¥! +100 ‚≠ê"
    elif user.user_id == ADMIN_ID and promo_code == "ADMINFOREVER":
        user.is_premium = True
        user.premium_expiry = None
        user.stars += 1000
        text = "üíé –ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω VIP –ø—Ä–æ–º–æ–∫–æ–¥!"
    else:
        text = "‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π –ø—Ä–æ–º–æ–∫–æ–¥"
    
    user.state = UserState.MAIN_MENU
    await message.answer(text, reply_markup=main_keyboard(user))
    user.mark_modified()
    await save_db()

# ===================== –û–°–ù–û–í–ù–û–ô –û–ë–†–ê–ë–û–¢–ß–ò–ö –°–û–û–ë–©–ï–ù–ò–ô ==================

@dp.message(Command("start", "help"))
async def send_welcome(message: Message):
    args = message.text.split()
    user = await get_user(message.from_user.id)
    user.menu_stack = []
    user.update_interaction()
    
    ref_code = args[1] if len(args) > 1 else None
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞
    if ref_code and ref_code.startswith("REF"):
        if user.has_subscribed:
            await process_referral(user, ref_code)
        else:
            user.pending_referral = ref_code
            user.mark_modified()
    
    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏
    if not user.has_subscribed:
        if await check_subscription(user.user_id):
            user.has_subscribed = True
            user.mark_modified()
        else:
            user.state = UserState.CHECK_SUBSCRIPTION
            await message.answer(
                "üì¢ –î–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –±–æ—Ç–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –Ω–∞—à –∫–∞–Ω–∞–ª!\n"
                "üëâ https://t.me/neurogptpro üëà\n\n"
                "–ü–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ",
                reply_markup=subscribe_keyboard()
            )
            return
    
    # –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ—Ñ–µ—Ä–∞–ª—å–Ω–æ–≥–æ –∫–æ–¥–∞ –ø–æ—Å–ª–µ –ø–æ–¥–ø–∏—Å–∫–∏
    if ref_code and ref_code.startswith("REF") and not user.referral_used:
        await process_referral(user, ref_code)
    
    welcome_text = (
        f"‚ú® <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, {html.quote(message.from_user.first_name)}!</b> ‚ú®\n"
        f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n"
        "üöÄ –í–∞—à AI-–∞—Å—Å–∏—Å—Ç–µ–Ω—Ç –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞:\n\n"
        "üé® <b>–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</b> - –≤–∏–∑—É–∞–ª–∏–∑–∏—Ä—É—é –ª—é–±—ã–µ –∏–¥–µ–∏\n"
        "üìù <b>–¢–µ–∫—Å—Ç–æ–≤—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç</b> - –ø–∏—à—É —Ç–µ–∫—Å—Ç—ã, —Å—Ç–∞—Ç—å–∏, —Å–∫—Ä–∏–ø—Ç—ã –∏ –ø—Ä–æ–≥—Ä–∞–º–º—ã\n"
        "üíé <b>–ü—Ä–µ–º–∏—É–º</b> - –±–µ–∑–ª–∏–º–∏—Ç–Ω–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π\n\n"
        f"üéÅ <b>–°—Ç–∞—Ä—Ç–æ–≤—ã–π –±–æ–Ω—É—Å:</b> {START_BALANCE_STARS} ‚≠ê\n"
        "<i>–ò—Å–ø–æ–ª—å–∑—É–π –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π!</i>\n\n"
        f"‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
    )
    user.state = UserState.MAIN_MENU
    await message.answer(welcome_text, reply_markup=main_keyboard(user))
    await save_db()

@dp.message(Command("balance"))
async def balance_command(message: Message):
    user = await get_user(message.from_user.id)
    if not await ensure_subscription(message, user):
        return
    
    user.state = UserState.BALANCE
    text = format_balance(user)
    await message.answer(text, reply_markup=balance_keyboard())

@dp.message(F.text)
async def handle_message(message: Message):
    user = await get_user(message.from_user.id)
    text = message.text.strip()
    user.update_interaction()
    
    if not await ensure_subscription(message, user):
        return
        
    try:
        if user.state == UserState.IMAGE_GEN:
            await generate_content(
                user, text, message,
                "image", IMAGE_COST, IMAGE_MODELS[user.image_model],
                image_options_keyboard(user),
                "last_image_prompt", "last_image_url",
                "–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ", "–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"
            )
            
        elif user.state == UserState.TEXT_GEN:
            await generate_text(user, text, message)
            
        elif user.state == UserState.AVATAR_GEN:
            await generate_content(
                user, text, message,
                "avatar", AVATAR_COST, IMAGE_MODELS[user.image_model],
                avatar_options_keyboard(),
                "last_avatar_prompt", "last_avatar_url",
                "–∞–≤–∞—Ç–∞—Ä", "–∞–≤–∞—Ç–∞—Ä—ã"
            )
            
        elif user.state == UserState.LOGO_GEN:
            await generate_content(
                user, text, message,
                "logo", LOGO_COST, IMAGE_MODELS[user.image_model],
                logo_options_keyboard(),
                "last_logo_prompt", "last_logo_url",
                "–ª–æ–≥–æ—Ç–∏–ø", "–ª–æ–≥–æ—Ç–∏–ø—ã"
            )
            
        elif user.state == UserState.ACTIVATE_PROMO:
            await process_promo_code(user, text, message)
            
    except Exception as e:
        logger.error(f"Error in handle_message: {e}")
        await animate_error(message, f"‚ö†Ô∏è <b>–û—à–∏–±–∫–∞:</b> {str(e)}")
    finally:
        await save_db()

# ===================== –ü–õ–ê–¢–ï–ñ–ò =====================
@dp.pre_checkout_query()
async def pre_checkout_handler(pre_checkout_query: PreCheckoutQuery):
    await bot.answer_pre_checkout_query(pre_checkout_query.id, ok=True)

@dp.message(F.successful_payment)
async def successful_payment_handler(message: Message):
    user = await get_user(message.from_user.id)
    payload = message.successful_payment.invoice_payload
    
    items = {
        "stars30": {"stars": 30, "message": "‚úÖ –ö—É–ø–ª–µ–Ω–æ 30 ‚≠ê"},
        "stars50": {"stars": 50, "message": "‚úÖ –ö—É–ø–ª–µ–Ω–æ 50 ‚≠ê"},
        "stars150": {"stars": 150, "message": "‚úÖ –ö—É–ø–ª–µ–Ω–æ 150 ‚≠ê"},
        "stars500": {"stars": 500, "message": "‚úÖ –ö—É–ø–ª–µ–Ω–æ 500 ‚≠ê"},
        "premium_month": {
            "premium": True, 
            "expiry": time.time() + 30 * 24 * 60 * 60,
            "message": "üíé –ü—Ä–µ–º–∏—É–º –Ω–∞ 1 –º–µ—Å—è—Ü –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!",
        },
        "premium_forever": {
            "premium": True, 
            "expiry": None,
            "message": "üíé –ü—Ä–µ–º–∏—É–º –ù–ê–í–°–ï–ì–î–ê –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω!",
        },
    }
    
    if payload in items:
        item = items[payload]
        text = item["message"]
        
        if "stars" in item:
            user.stars += item["stars"]
        elif "premium" in item:
            user.is_premium = True
            user.premium_expiry = item.get("expiry")
        
        user.mark_modified()
        await message.answer(text)
    else:
        await message.answer(f"–ü–ª–∞—Ç–µ–∂ –ø–æ–ª—É—á–µ–Ω, –Ω–æ —Ç–æ–≤–∞—Ä –Ω–µ —Ä–∞—Å–ø–æ–∑–Ω–∞–Ω: {payload}")
    
    await save_db()

@dp.message(Command("paysupport"))
async def pay_support_handler(message: Message):
    await message.answer(
        "–ü–æ–¥–¥–µ—Ä–∂–∫–∞ –ø–æ –ø–ª–∞—Ç–µ–∂–∞–º: @payment_admin\n\n"
        "–í–æ–∑–≤—Ä–∞—Ç —Å—Ä–µ–¥—Å—Ç–≤ –≤–æ–∑–º–æ–∂–µ–Ω –≤ —Ç–µ—á–µ–Ω–∏–µ 14 –¥–Ω–µ–π"
    )
# ... (–ø—Ä–µ–¥—ã–¥—É—â–∏–π –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π –¥–æ —Å–æ–∑–¥–∞–Ω–∏—è app) ...

# ===================== –§–û–ù–û–í–´–ï –ó–ê–î–ê–ß–ò =====================
async def auto_save_db():
    """–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –∫–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç"""
    while True:
        await asyncio.sleep(300)
        if any(user._modified for user in users_db.values()):
            await save_db()
            logger.info("Database auto-saved")

async def clean_inactive_sessions():
    """–û—á–∏—Å—Ç–∫–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π"""
    while True:
        await asyncio.sleep(3600)  # –ö–∞–∂–¥—ã–π —á–∞—Å
        current_time = time.time()
        inactive_users = []
        
        for user_id, user in users_db.items():
            if current_time - user.last_interaction > SESSION_TIMEOUT:
                inactive_users.append(user_id)
        
        for user_id in inactive_users:
            if user_id != ADMIN_ID:  # –ù–µ —É–¥–∞–ª—è–µ–º –∞–¥–º–∏–Ω–∞
                del users_db[user_id]
                logger.info(f"Cleaned inactive session: {user_id}")
        
        await save_db()

async def self_pinger():
    """–†–µ–≥—É–ª—è—Ä–Ω—ã–µ ping-–∑–∞–ø—Ä–æ—Å—ã –¥–ª—è –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏—è —Å–Ω–∞ —Å–µ—Ä–≤–∏—Å–∞"""
    RENDER_APP_URL = "https://aibot-plcn.onrender.com"
    while True:
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(RENDER_APP_URL, timeout=10) as response:
                    logger.info(f"Self-ping status: {response.status}")
        except Exception as e:
            logger.error(f"Self-ping failed: {str(e)}")
        await asyncio.sleep(600)  # 10 –º–∏–Ω—É—Ç

# ===================== –û–ü–†–ï–î–ï–õ–ï–ù–ò–ï RUN_BOT =====================
async def run_bot():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞ –±–æ—Ç–∞"""
    try:
        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        await load_db()
        
        bot_info = await bot.get_me()
        logger.info(f"Bot @{bot_info.username} started")
        
        # –§–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏
        asyncio.create_task(auto_save_db())
        asyncio.create_task(clean_inactive_sessions())
        
        # –û—á–∏—Å—Ç–∫–∞ –ø—Ä–µ–¥—ã–¥—É—â–∏—Ö –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π
        await bot.delete_webhook(drop_pending_updates=True)
        
        # –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞
        await dp.start_polling(bot, skip_updates=True)
    except Exception as e:
        logger.error(f"Bot crashed: {e}")
        # –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ 30 —Å–µ–∫—É–Ω–¥ –ø—Ä–∏ –æ—à–∏–±–∫–µ
        await asyncio.sleep(30)
        asyncio.create_task(run_bot())

# ===================== LIFESPAN HANDLER =====================
from contextlib import asynccontextmanager

@asynccontextmanager
async def lifespan(app: FastAPI):
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∂–∏–∑–Ω–µ–Ω–Ω—ã–º —Ü–∏–∫–ª–æ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
    # –ó–∞–ø—É—Å–∫ –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ
    asyncio.create_task(run_bot())
    asyncio.create_task(self_pinger())
    yield
    # –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ø—Ä–∏ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏
    # –ó–∞–∫—Ä—ã–≤–∞–µ–º —Å–µ—Å—Å–∏—é –±–æ—Ç–∞
    await bot.session.close()

app = FastAPI(lifespan=lifespan)

# ===================== ENDPOINT –î–õ–Ø –ü–†–û–í–ï–†–ö–ò =====================
@app.get("/")
async def health_check():
    return {
        "status": "ok",
        "bot": "active",
        "render": "keep-alive"
    }

# ... (–æ—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π) ...

# –£–¥–∞–ª—è–µ–º –¥—É–±–ª–∏—Ä—É—é—â–∏–µ—Å—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è run_bot –∏ self_pinger

# –£–¥–∞–ª—è–µ–º –±–ª–æ–∫ —Å @app.on_event("startup"), –ø–æ—Ç–æ–º—É —á—Ç–æ –º—ã –∏—Å–ø–æ–ª—å–∑—É–µ–º lifespan

if __name__ == "__main__":
    port = int(os.environ.get("PORT", 8000))
    uvicorn.run(
        app,  # –ò—Å–ø–æ–ª—å–∑—É–µ–º —Å–æ–∑–¥–∞–Ω–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
        host="0.0.0.0",
        port=port,
        workers=1,
        loop="asyncio",
        timeout_keep_alive=60
    )
